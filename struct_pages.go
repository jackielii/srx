package srx

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"path"
	"reflect"
	"runtime"
)

type StructPages struct {
	onError     func(http.ResponseWriter, *http.Request, error)
	middlewares []func(http.Handler, *PageNode) http.Handler
}

func NewStructPages(options ...func(*StructPages)) *StructPages {
	reg := &StructPages{
		onError: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		},
	}
	for _, opt := range options {
		opt(reg)
	}
	return reg
}

func WithErrorHandler(onError func(http.ResponseWriter, *http.Request, error)) func(*StructPages) {
	return func(pr *StructPages) {
		pr.onError = onError
	}
}

func WithMiddlewares(middlewares ...func(http.Handler, *PageNode) http.Handler) func(*StructPages) {
	return func(pr *StructPages) {
		pr.middlewares = append(pr.middlewares, middlewares...)
	}
}

func (sp *StructPages) MountPages(router Router, route string, page any, initArgs ...any) {
	pc := parsePageTree(route, page, initArgs...)
	sp.registerPageItem(router, pc, pc.rootNode, route)
}

func (pr *StructPages) registerPageItem(router Router, pc *parseContext, page *PageNode, parentRoute string) {
	if page.Route == "" {
		panic("Page item route is empty: " + page.Name)
	}
	if page.Page == nil && page.Partial == nil {
		println("Registering route group", "name", page.Name, "route", path.Join(parentRoute, page.Route))
		router.Route(page.Route, func(router Router) {
			for _, child := range page.Children {
				pr.registerPageItem(router, pc, child, page.Route)
			}
		})
		return
	}
	if page.Page == nil {
		panic("Page item " + page.Name + " does not have a Page method")
	}
	if page.Page.Type.NumIn() > 1 && page.Args == nil {
		panic("Page method on " + page.Name + " requires args, but Args method not declared")
	}
	if page.Partial != nil && page.Partial.Type.NumIn() > 1 && page.Args == nil {
		panic("Partial method on " + page.Name + " requires args, but Args method not declared")
	}
	// TODO: this is problematic as the function itself may panic
	// dry run Args method to make sure the required arguments are available
	// if page.Args != nil {
	// 	emptyRequest, _ := http.NewRequest("GET", "/", nil)
	// 	pc.callMethod(page.Value, *page.Args, reflect.ValueOf(emptyRequest))
	// }

	println("Registering page item", "name", page.Name, "route", path.Join(parentRoute, page.Route), "title", page.Title)
	var handler http.Handler
	handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var args []reflect.Value
		if page.Args != nil {
			args = pc.callMethod(page.Value, *page.Args, reflect.ValueOf(r))
			var err error
			args, err = extractError(args)
			if err != nil {
				pr.onError(w, r, fmt.Errorf("error calling Args method on %s: %w", page.Name, err))
				return
			}
		}

		if isHTMX(r) {
			if page.Partial != nil {
				comp := pc.callTemplMethod(page.Value, *page.Partial, args...)
				if err := comp.Render(r.Context(), w); err != nil {
					pr.onError(w, r, err)
				}
			} else {
				comp := pc.callTemplMethod(page.Value, *page.Page, args...)
				w.Header().Set("HX-Retarget", "body")
				if err := comp.Render(r.Context(), w); err != nil {
					pr.onError(w, r, err)
				}
			}
		} else {
			comp := pc.callTemplMethod(page.Value, *page.Page, args...)
			if err := comp.Render(r.Context(), w); err != nil {
				pr.onError(w, r, err)
			}
		}
	})
	for _, middleware := range pr.middlewares {
		handler = middleware(handler, page)
	}
	router.HandleMethod("get", page.Route, handler)
}

type templComponent interface {
	Render(context.Context, io.Writer) error
}

func returnsTemplComponent(t reflect.Method) bool {
	templComponent := reflect.TypeOf((*templComponent)(nil)).Elem()
	if t.Type.NumOut() != 1 {
		return false
	}
	return t.Type.Out(0).Implements(templComponent)
}

func isPromotedMethod(method reflect.Method) bool {
	// Check if the method is promoted from an embedded type
	// https://github.com/golang/go/issues/73883
	wPC := method.Func.Pointer()
	wFunc := runtime.FuncForPC(wPC)
	wFile, wLine := wFunc.FileLine(wPC)
	return wFile == "<autogenerated>" && wLine == 1
}

var errorType = reflect.TypeOf((*error)(nil)).Elem()

func extractError(args []reflect.Value) ([]reflect.Value, error) {
	var err error
	if len(args) >= 1 && args[len(args)-1].Type().AssignableTo(errorType) {
		i := args[len(args)-1].Interface()
		args = args[:len(args)-1]
		if i == nil {
			return args, nil
		}
		err = i.(error)
	}
	return args, err
}

func formatMethod(method *reflect.Method) string {
	if method == nil || method.Func == (reflect.Value{}) {
		return "<nil>"
	}
	return fmt.Sprintf("%s.%s", method.Type.In(0).String(), method.Name)
}

func isHTMX(r *http.Request) bool {
	return r.Header.Get("HX-Request") == "true"
}
